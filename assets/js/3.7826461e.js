(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{665:function(t,s,a){t.exports=a.p+"assets/img/1.ceca7cb8.png"},666:function(t,s,a){t.exports=a.p+"assets/img/2.5486dee3.png"},667:function(t,s,a){t.exports=a.p+"assets/img/3.588a8478.png"},668:function(t,s,a){t.exports=a.p+"assets/img/4.a6f44878.png"},669:function(t,s,a){t.exports=a.p+"assets/img/5.4bfb6d17.png"},670:function(t,s,a){t.exports=a.p+"assets/img/6.08657960.png"},671:function(t,s,a){t.exports=a.p+"assets/img/7.c979b863.png"},672:function(t,s,a){t.exports=a.p+"assets/img/8.e25e8e67.png"},673:function(t,s,a){t.exports=a.p+"assets/img/9.bfad80e7.png"},674:function(t,s,a){t.exports=a.p+"assets/img/10.f253b161.png"},675:function(t,s,a){t.exports=a.p+"assets/img/11.0ff321d7.png"},676:function(t,s,a){t.exports=a.p+"assets/img/12.eadb7eab.png"},677:function(t,s,a){t.exports=a.p+"assets/img/13.0cf84b8f.png"},678:function(t,s,a){t.exports=a.p+"assets/img/14.24de565c.png"},763:function(t,s,a){"use strict";a.r(s);var n=a(2),r=Object(n.a)({},function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_2020-12-05期代码走查"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2020-12-05期代码走查","aria-hidden":"true"}},[t._v("#")]),t._v(" 2020-12-05期代码走查")]),t._v(" "),n("hr"),t._v(" "),n("h4",{attrs:{id:"发现问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#发现问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 发现问题")]),t._v(" "),n("p",[n("strong",[t._v("1、（蓝色框）不要使用 var 关键字声明变量，而是优先使用 const，如果是可变变量，则使用 let")])]),t._v(" "),n("p",[n("strong",[t._v("2、（红色框）通过 platformMark 变量进行多环境配置时，其实就是多分支控制，可以考虑使用 switch 表达式去控制，同时也能够将同一代码逻辑整合在一起，提高代码的可读性和可维护性")])]),t._v(" "),n("p",[n("img",{attrs:{src:a(665),alt:"图片1"}})]),t._v(" "),n("p",[n("strong",[t._v("3、（蓝色框）如果 Domain 是挂载在全局 window 对象上的话，那么在使用时尽量通过 window.Domain 的方式调用，因为如果项目引入了 ESLint 等工具，那么此处是会报错的，但是也可以通过配置 eslintrc 文件的 globals 选项去 fix 掉该错误，但还是尽量保持变量的可追溯性")])]),t._v(" "),n("p",[n("img",{attrs:{src:a(666),alt:"图片2"}})]),t._v(" "),n("p",[n("strong",[t._v("4、（蓝色框）以下是一个搜索按钮，在点击触发后的代码逻辑走向")])]),t._v(" "),n("p",[t._v("引入 seachBoxContainer 组件\n"),n("img",{attrs:{src:a(667),alt:"图片3"}})]),t._v(" "),n("p",[t._v("在 seachBoxContainer 组件内部触发搜索\n"),n("img",{attrs:{src:a(668),alt:"图片4"}})]),t._v(" "),n("p",[t._v("直接调用父组件的搜索方法（这里应该要通过 $emit 的方式调用的）\n"),n("img",{attrs:{src:a(669),alt:"图片5"}})]),t._v(" "),n("p",[t._v("接着父组件直接调用 tableBoxContainer 组件中的 tableBox 组件中的 mockTableData 方法\n"),n("img",{attrs:{src:a(670),alt:"图片6"}})]),t._v(" "),n("p",[n("img",{attrs:{src:a(671),alt:"图片7"}})]),t._v(" "),n("p",[n("img",{attrs:{src:a(672),alt:"图片8"}})]),t._v(" "),n("p",[n("img",{attrs:{src:a(673),alt:"图片9"}})]),t._v(" "),n("p",[t._v("经过追溯 mockTableData 方法，找到真正触发请求的方法\n"),n("img",{attrs:{src:a(674),alt:"图片10"}})]),t._v(" "),n("p",[t._v("接着找到请求的 API 地址\n"),n("img",{attrs:{src:a(675),alt:"图片11"}})]),t._v(" "),n("p",[t._v("组装数据\n"),n("img",{attrs:{src:a(676),alt:"图片12"}})]),t._v(" "),n("p",[t._v("直接通过组件的 data 数据 TableItem 插入数据，接着渲染\n"),n("img",{attrs:{src:a(677),alt:"图片13"}})]),t._v(" "),n("p",[n("img",{attrs:{src:a(678),alt:"图片14"}})]),t._v(" "),n("p",[t._v("在这一个代码逻辑中，发现了小部分问题：")]),t._v(" "),n("ul",[n("li",[t._v("子组件没有通过 $emit 的方式去调用父组件的方法")]),t._v(" "),n("li",[t._v("一个搜索逻辑，却涉及了6个文件，难以维护，其中还没包括搜索条件的处理所涉及的地方")]),t._v(" "),n("li",[t._v("虽然从代码上可以看出，这个逻辑是与其他的搜索逻辑统一封装起来的，但是我们在封装的时候，是否还需要考虑到代码的可读性以及代码的可追溯性，或许这样封装会加快后面的开发以及带来些许的方便，但是这种代码逻辑走向不够“明确”，且臃肿的封装方式，是很难去维护的")])]),t._v(" "),n("hr"),t._v(" "),n("h4",{attrs:{id:"走查总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#走查总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 走查总结")]),t._v(" "),n("p",[t._v("本次代码走查，个人觉得最大的问题就是代码的可维护性，而且是由于代码封装所带来的问题。在代码逻辑上进行统一封装是一件好事，可以加快后面的开发，但是我们在封装的同时，是否也应该要考虑代码的可读性、可维护性和可追溯性，即你所封装的东西，如果由第二个人来使用、修改，或者二次封装时，是否会简单高效呢？我觉得这是应该要考虑的问题。")])])},[],!1,null,null,null);s.default=r.exports}}]);